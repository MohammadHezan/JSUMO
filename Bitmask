#define L_RPWM 10
#define L_LPWM 9
#define R_RPWM 5
#define R_LPWM 3

#define LINE_FL A1
#define LINE_FR A3
#define LINE_BL A0
#define LINE_BR A2

#define IR_LEFT       2
#define IR_CENTER     8
#define IR_RIGHT      7
#define IR_SIDE_LEFT  4
#define IR_SIDE_RIGHT 6

const int ATTACK_SPEED = 255;
const int TURN_SPEED   = 180;
const int SEARCH_SPEED = 150;
const int BACK_SPEED   = 200;

unsigned long lastSensorRead = 0;
unsigned long lastDecision   = 0;
unsigned long lastMoveUpdate = 0;
unsigned long searchTimer    = 0;
unsigned long turnStart      = 0;

const unsigned long SENSOR_INTERVAL   = 30;
const unsigned long DECISION_INTERVAL = 50;
const unsigned long MOVE_INTERVAL     = 20;
const unsigned long SIDE_TURN_TIME    = 300;

int searchAngle = 0;
const int SEARCH_STEP = 15;
bool turning = false;
int turnDirection = 0;

enum State { LINE_FOLLOW, ATTACK, SEARCH };
State robotState = SEARCH;

enum EnemyDir { NONE, LEFT, CENTER, RIGHT };
EnemyDir lastEnemyDirection = NONE;

byte lineSensors = 0;
byte irSensors   = 0;

int readSensor(int pin) {
  int sum = 0;
  for(int i = 0; i < 3; i++) sum += digitalRead(pin);
  return (sum >= 2);
}

void setMotors(int l_fwd, int l_bwd, int r_fwd, int r_bwd) {
  analogWrite(L_RPWM, l_fwd);
  analogWrite(L_LPWM, l_bwd);
  analogWrite(R_RPWM, r_fwd);
  analogWrite(R_LPWM, r_bwd);
}

void moveLeft(int speed)     { setMotors(0, speed, speed, 0); }
void moveRight(int speed)    { setMotors(speed, 0, 0, speed); }
void moveForward(int speed)  { setMotors(speed, 0, speed, 0); }
void moveBackward(int speed) { setMotors(0, speed, 0, speed); }
void stopMotors()            { setMotors(0,0,0,0); }

void handleLineEdgeCases(byte s) {
  switch(s) {
    case 0b1100: moveBackward(BACK_SPEED); break;
    case 0b0011: moveForward(BACK_SPEED); break;
    case 0b1000: case 0b1010: moveBackward(BACK_SPEED); moveRight(TURN_SPEED); break;
    case 0b0100: case 0b0110: moveBackward(BACK_SPEED); moveLeft(TURN_SPEED); break;
    case 0b0010: moveForward(BACK_SPEED); moveRight(TURN_SPEED); break;
    case 0b0001: moveForward(BACK_SPEED); moveLeft(TURN_SPEED); break;
    case 0b0000: stopMotors(); break;
  }
}

void setup() {
  pinMode(L_RPWM, OUTPUT); pinMode(L_LPWM, OUTPUT);
  pinMode(R_RPWM, OUTPUT); pinMode(R_LPWM, OUTPUT);
  pinMode(LINE_FL, INPUT); pinMode(LINE_FR, INPUT);
  pinMode(LINE_BL, INPUT); pinMode(LINE_BR, INPUT);
  pinMode(IR_LEFT, INPUT); pinMode(IR_CENTER, INPUT); pinMode(IR_RIGHT, INPUT);
  pinMode(IR_SIDE_LEFT, INPUT); pinMode(IR_SIDE_RIGHT, INPUT);
}

void loop() {
  unsigned long now = millis();

  if(now - lastSensorRead >= SENSOR_INTERVAL) {
    lastSensorRead = now;
    lineSensors = (readSensor(LINE_FL) << 3) | (readSensor(LINE_FR) << 2) |
                  (readSensor(LINE_BL) << 1) |  readSensor(LINE_BR);
    irSensors   = (readSensor(IR_SIDE_LEFT) << 4) | (readSensor(IR_LEFT) << 3) |
                  (readSensor(IR_CENTER) << 2) | (readSensor(IR_RIGHT) << 1) |
                  readSensor(IR_SIDE_RIGHT);
  }

  if(now - lastDecision >= DECISION_INTERVAL) {
    lastDecision = now;
    if(lineSensors != 0b1111) robotState = LINE_FOLLOW;
    else if(irSensors != 0b11111) robotState = ATTACK;
    else robotState = SEARCH;
  }

  if(now - lastMoveUpdate >= MOVE_INTERVAL) {
    lastMoveUpdate = now;
    switch(robotState) {
      case LINE_FOLLOW:
        handleLineEdgeCases(lineSensors);
        break;

      case ATTACK:
        if(!(irSensors & 0b00100)) { moveForward(ATTACK_SPEED); lastEnemyDirection = CENTER; turning = false; }
        else if(!(irSensors & 0b01000)) { moveLeft(TURN_SPEED); moveForward(100); lastEnemyDirection = LEFT; }
        else if(!(irSensors & 0b00010)) { moveRight(TURN_SPEED); moveForward(100); lastEnemyDirection = RIGHT; }
        else if(!(irSensors & 0b10000)) { turning = true; turnStart = now; turnDirection = -1; }
        else if(!(irSensors & 0b00001)) { turning = true; turnStart = now; turnDirection = 1; }

        if(turning) {
          if(now - turnStart < SIDE_TURN_TIME) {
            if(turnDirection == -1) moveLeft(TURN_SPEED);
            else moveRight(TURN_SPEED);
          } else turning = false;
        }
        break;

      case SEARCH:
        if(now - searchTimer > 150) {
          searchAngle += SEARCH_STEP;
          if(searchAngle >= 180) searchAngle = 0;
          searchTimer = now;
        }
        if(lastEnemyDirection == LEFT) { if(searchAngle < 90) moveLeft(SEARCH_SPEED); else moveRight(SEARCH_SPEED); }
        else if(lastEnemyDirection == RIGHT) { if(searchAngle < 90) moveRight(SEARCH_SPEED); else moveLeft(SEARCH_SPEED); }
        else { if(searchAngle < 90) moveRight(SEARCH_SPEED); else moveLeft(SEARCH_SPEED); }
        moveForward(SEARCH_SPEED/2);
        break;
    }
  }
}
